# Voice Memory - 数据模型文档

**版本：** v1.0
**日期：** 2025-12-29
**状态：** 最终设计版本

---

## 目录

1. [数据架构概述](#一数据架构概述)
2. [数据库Schema](#二数据库schema)
3. [实体关系模型](#三实体关系模型)
4. [Markdown文件格式](#四markdown文件格式)
5. [API数据模型](#五api数据模型)
6. [索引策略](#六索引策略)
7. [数据迁移](#七数据迁移)

---

## 一、数据架构概述

### 1.1 存储架构

```
┌─────────────────────────────────────────────────────────────┐
│                   Voice Memory 存储架构                      │
└─────────────────────────────────────────────────────────────┘

┌─────────────────┐        ┌─────────────────┐
│  Markdown 文件  │        │   SQLite 数据库  │
│   (人类可读)     │◄──────►│    (结构化)      │
└─────────────────┘        └─────────────────┘
        │                           │
        │                           │
   文件存储                     索引和查询
   版本控制                     关系管理
   Obsidian                     快速检索
```

### 1.2 设计原则

```yaml
本地优先:
  ✅ 数据存储在本地设备
  ✅ 完全用户控制
  ✅ 隐私保护

人类可读:
  ✅ Markdown格式
  ✅ 文本可直接编辑
  ✅ Git版本控制

结构化查询:
  ✅ SQLite索引
  ✅ 快速检索
  ✅ 关系管理

可扩展性:
  ✅ 支持向量数据库（Phase 2+）
  ✅ 支持云同步
  ✅ 支持多设备
```

---

## 二、数据库Schema

### 2.1 表结构总览

```sql
-- 核心表
entities           -- 实体（笔记）
observations       -- 观察记录
relations          -- 关系
conversations      -- 会话
messages           -- 消息
users              -- 用户

-- 索引表
tags               -- 标签
categories         -- 分类
entity_tags        -- 实体标签关联
```

### 2.2 entities（实体表）

```sql
CREATE TABLE entities (
    -- 主键
    id INTEGER PRIMARY KEY AUTOINCREMENT,

    -- 基本信息
    title TEXT NOT NULL,                    -- 标题
    permalink TEXT UNIQUE NOT NULL,         -- 永久链接
    type TEXT DEFAULT 'note',               -- 类型: note, observation, idea

    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- 元数据
    source TEXT,                            -- 来源: conversation, manual, api
    source_id TEXT,                         -- 来源ID

    -- 统计
    view_count INTEGER DEFAULT 0,           -- 查看次数
    edit_count INTEGER DEFAULT 0,           -- 编辑次数

    -- 文件路径
    markdown_path TEXT                      -- Markdown文件路径
);

CREATE INDEX idx_entities_permalink ON entities(permalink);
CREATE INDEX idx_entities_type ON entities(type);
CREATE INDEX idx_entities_created_at ON entities(created_at DESC);
CREATE INDEX idx_entities_updated_at ON entities(updated_at DESC);
```

**字段说明：**

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | INTEGER | PRIMARY KEY | 自增主键 |
| title | TEXT | NOT NULL | 笔记标题 |
| permalink | TEXT | UNIQUE NOT NULL | 永久链接，用于URL和文件名 |
| type | TEXT | DEFAULT 'note' | 实体类型：note, observation, idea |
| created_at | TIMESTAMP | DEFAULT NOW | 创建时间 |
| updated_at | TIMESTAMP | DEFAULT NOW | 更新时间 |
| source | TEXT | | 来源标识 |
| source_id | TEXT | | 来源ID（如conversation_id） |
| view_count | INTEGER | DEFAULT 0 | 查看次数统计 |
| edit_count | INTEGER | DEFAULT 0 | 编辑次数统计 |
| markdown_path | TEXT | | Markdown文件相对路径 |

---

### 2.3 observations（观察记录表）

```sql
CREATE TABLE observations (
    -- 主键
    id INTEGER PRIMARY KEY AUTOINCREMENT,

    -- 关联
    entity_id INTEGER NOT NULL,             -- 所属实体

    -- 内容
    category TEXT,                          -- 分类
    content TEXT NOT NULL,                  -- 观察内容
    tags TEXT,                              -- 标签（JSON数组）
    context TEXT,                           -- 上下文

    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- 外键约束
    FOREIGN KEY (entity_id) REFERENCES entities(id) ON DELETE CASCADE
);

CREATE INDEX idx_observations_entity_id ON observations(entity_id);
CREATE INDEX idx_observations_category ON observations(category);
CREATE INDEX idx_observations_created_at ON observations(created_at DESC);
```

**字段说明：**

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | INTEGER | PRIMARY KEY | 自增主键 |
| entity_id | INTEGER | FOREIGN KEY | 所属实体ID |
| category | TEXT | | 观察分类（如"技术要点"、"灵感"） |
| content | TEXT | NOT NULL | 观察内容 |
| tags | TEXT | | 标签JSON数组：`["tag1", "tag2"]` |
| context | TEXT | | 上下文说明 |
| created_at | TIMESTAMP | DEFAULT NOW | 创建时间 |

---

### 2.4 relations（关系表）

```sql
CREATE TABLE relations (
    -- 主键
    id INTEGER PRIMARY KEY AUTOINCREMENT,

    -- 关联
    source_entity_id INTEGER NOT NULL,      -- 源实体
    target_entity_id INTEGER NOT NULL,      -- 目标实体

    -- 关系
    relation_type TEXT NOT NULL,            -- 关系类型
    context TEXT,                           -- 上下文说明

    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- 外键约束
    FOREIGN KEY (source_entity_id) REFERENCES entities(id) ON DELETE CASCADE,
    FOREIGN KEY (target_entity_id) REFERENCES entities(id) ON DELETE CASCADE,

    -- 唯一约束
    UNIQUE(source_entity_id, target_entity_id, relation_type)
);

CREATE INDEX idx_relations_source ON relations(source_entity_id);
CREATE INDEX idx_relations_target ON relations(target_entity_id);
CREATE INDEX idx_relations_type ON relations(relation_type);

-- 防止循环关系的触发器
CREATE TRIGGER prevent_circular_relations
BEFORE INSERT ON relations
FOR EACH ROW
BEGIN
    SELECT CASE
        WHEN EXISTS (
            SELECT 1 FROM relations
            WHERE source_entity_id = NEW.target_entity_id
            AND target_entity_id = NEW.source_entity_id
        )
        THEN RAISE(ABORT, 'Circular relation detected')
    END;
END;
```

**字段说明：**

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | INTEGER | PRIMARY KEY | 自增主键 |
| source_entity_id | INTEGER | FOREIGN KEY | 源实体ID |
| target_entity_id | INTEGER | FOREIGN KEY | 目标实体ID |
| relation_type | TEXT | NOT NULL | 关系类型 |
| context | TEXT | | 关系上下文说明 |
| created_at | TIMESTAMP | DEFAULT NOW | 创建时间 |

**关系类型枚举：**

```yaml
relates_to: 相关联
builds_on: 建立于
contradicts: 矛盾
extends: 扩展
supports: 支持
questions: 质疑
exemplifies: 例证
clarifies: 阐明
```

---

### 2.5 conversations（会话表）

```sql
CREATE TABLE conversations (
    -- 主键
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    conversation_id TEXT UNIQUE NOT NULL,   -- 会话ID（UUID）

    -- 基本信息
    title TEXT,                             -- 会话标题
    system_prompt TEXT,                     -- 系统提示词

    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- 统计
    message_count INTEGER DEFAULT 0,        -- 消息数量
    total_tokens INTEGER DEFAULT 0          -- 总token数
);

CREATE INDEX idx_conversations_conversation_id ON conversations(conversation_id);
CREATE INDEX idx_conversations_created_at ON conversations(created_at DESC);
CREATE INDEX idx_conversations_updated_at ON conversations(updated_at DESC);
```

**字段说明：**

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | INTEGER | PRIMARY KEY | 自增主键 |
| conversation_id | TEXT | UNIQUE NOT NULL | 会话UUID |
| title | TEXT | | 会话标题（可选） |
| system_prompt | TEXT | | 系统提示词（可选） |
| created_at | TIMESTAMP | DEFAULT NOW | 创建时间 |
| updated_at | TIMESTAMP | DEFAULT NOW | 更新时间 |
| message_count | INTEGER | DEFAULT 0 | 消息数量 |
| total_tokens | INTEGER | DEFAULT 0 | 总token使用量 |

---

### 2.6 messages（消息表）

```sql
CREATE TABLE messages (
    -- 主键
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_id TEXT UNIQUE NOT NULL,        -- 消息ID（UUID）

    -- 关联
    conversation_id TEXT NOT NULL,          -- 所属会话

    -- 内容
    role TEXT NOT NULL,                     -- 角色: user, assistant, system
    content TEXT NOT NULL,                  -- 消息内容

    -- AI使用信息
    input_tokens INTEGER DEFAULT 0,         -- 输入token数
    output_tokens INTEGER DEFAULT 0,        -- 输出token数
    model TEXT,                             -- 使用的模型

    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- 外键约束
    FOREIGN KEY (conversation_id) REFERENCES conversations(conversation_id) ON DELETE CASCADE
);

CREATE INDEX idx_messages_message_id ON messages(message_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at ASC);
```

**字段说明：**

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | INTEGER | PRIMARY KEY | 自增主键 |
| message_id | TEXT | UNIQUE NOT NULL | 消息UUID |
| conversation_id | TEXT | FOREIGN KEY | 所属会话ID |
| role | TEXT | NOT NULL | 角色：user, assistant, system |
| content | TEXT | NOT NULL | 消息内容 |
| input_tokens | INTEGER | DEFAULT 0 | 输入token数 |
| output_tokens | INTEGER | DEFAULT 0 | 输出token数 |
| model | TEXT | | 使用的AI模型 |
| created_at | TIMESTAMP | DEFAULT NOW | 创建时间 |

---

### 2.7 users（用户表）

```sql
CREATE TABLE users (
    -- 主键
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT UNIQUE NOT NULL,           -- 用户ID（UUID）

    -- 基本信息
    username TEXT UNIQUE NOT NULL,          -- 用户名
    email TEXT UNIQUE,                      -- 邮箱
    api_key TEXT UNIQUE,                    -- API密钥

    -- 配置
    preferences TEXT,                       -- 偏好设置（JSON）

    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- 状态
    is_active BOOLEAN DEFAULT true,
    last_login_at TIMESTAMP
);

CREATE INDEX idx_users_user_id ON users(user_id);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_api_key ON users(api_key);
```

**字段说明：**

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | INTEGER | PRIMARY KEY | 自增主键 |
| user_id | TEXT | UNIQUE NOT NULL | 用户UUID |
| username | TEXT | UNIQUE NOT NULL | 用户名 |
| email | TEXT | UNIQUE | 邮箱 |
| api_key | TEXT | UNIQUE | API密钥 |
| preferences | TEXT | | 偏好设置JSON |
| created_at | TIMESTAMP | DEFAULT NOW | 创建时间 |
| updated_at | TIMESTAMP | DEFAULT NOW | 更新时间 |
| is_active | BOOLEAN | DEFAULT true | 是否激活 |
| last_login_at | TIMESTAMP | | 最后登录时间 |

---

### 2.8 tags（标签表）

```sql
CREATE TABLE tags (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,              -- 标签名称
    color TEXT DEFAULT '#3498db',          -- 标签颜色
    description TEXT,                       -- 标签描述
    usage_count INTEGER DEFAULT 0,         -- 使用次数
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_tags_name ON tags(name);
CREATE INDEX idx_tags_usage_count ON tags(usage_count DESC);
```

---

### 2.9 entity_tags（实体标签关联表）

```sql
CREATE TABLE entity_tags (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    entity_id INTEGER NOT NULL,
    tag_id INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (entity_id) REFERENCES entities(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE,
    UNIQUE(entity_id, tag_id)
);

CREATE INDEX idx_entity_tags_entity_id ON entity_tags(entity_id);
CREATE INDEX idx_entity_tags_tag_id ON entity_tags(tag_id);
```

---

## 三、实体关系模型

### 3.1 ER图

```
┌──────────────┐
│    users     │
└──────┬───────┘
       │
       │ 1:N
       ▼
┌──────────────┐         ┌──────────────┐
│conversations │────────▶│  messages    │
└──────────────┘         └──────────────┘

┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│  entities    │────────▶│observations  │◄────────│  users       │
└──────┬───────┘         └──────────────┘         └──────────────┘
       │
       │ N:M (self-referencing)
       ▼
┌──────────────┐
│  relations   │
└──────────────┘

┌──────────────┐         ┌──────────────┐
│  entities    │◄────────│entity_tags   │
└──────────────┘         └──────┬───────┘
                                │
                                │ N:1
                                ▼
                         ┌──────────────┐
                         │    tags      │
                         └──────────────┘
```

### 3.2 关系说明

**User ↔ Conversation**: 1:N
- 一个用户可以有多个会话
- 一个会话属于一个用户

**Conversation ↔ Message**: 1:N
- 一个会话包含多条消息
- 一条消息属于一个会话

**Entity ↔ Observation**: 1:N
- 一个实体包含多条观察记录
- 一条观察记录属于一个实体

**Entity ↔ Relation**: N:M (自引用)
- 一个实体可以关联多个其他实体
- 关系有类型和方向

**Entity ↔ Tag**: N:M
- 一个实体可以有多个标签
- 一个标签可以用于多个实体

---

## 四、Markdown文件格式

### 4.1 文件结构

```
storage/
├── markdown/
│   ├── 2025/
│   │   ├── 12/
│   │   │   ├── 29/
│   │   │   │   ├── note-permalink-123.md
│   │   │   │   ├── another-note.md
│   │   │   │   └── ...
│   │   │   └── ...
│   │   └── ...
│   └── ...
└── memory.db
```

### 4.2 Markdown文件模板

```markdown
---
title: 笔记标题
permalink: note-permalink-123
tags:
  - tag1
  - tag2
type: note
created: 2025-12-29
updated: 2025-12-29
source: conversation
source_id: conv_123456
---

# 笔记标题

## 概述

笔记的概述内容...

## 观察记录

### [技术要点] 微服务架构的关键考虑
#microservices #architecture

微服务需要考虑服务发现、配置管理、API网关等。

### [灵感] 可能的改进方向
#idea

考虑引入事件驱动架构...

## 关系

- relates_to [[another-note-permalink]]
- builds_on [[foundational-concept]]

- [[related-note-1]]: 相关讨论
- [[related-note-2]]: 补充说明

## 元数据

- **创建时间**: 2025-12-29 12:00:00
- **来源**: 对话会话 conv_123456
- **编辑次数**: 3
- **查看次数**: 15

---

*最后更新: 2025-12-29 12:30:00*
```

### 4.3 Front Matter规范

```yaml
必需字段:
  title: 笔记标题
  permalink: 永久链接（用于URL和文件名）
  created: 创建日期（YYYY-MM-DD）

可选字段:
  tags: [tag1, tag2]              # 标签列表
  type: note                      # 类型: note, observation, idea
  updated: 2025-12-29              # 更新日期
  source: conversation            # 来源: conversation, manual, api
  source_id: conv_123456          # 来源ID
  categories: [技术笔记]           # 分类列表
  status: active                  # 状态: active, archived, deleted
```

### 4.4 Wiki链接语法

```markdown
# 内部链接（双向关联）
- [[another-note-permalink]]        # 基本链接
- [[note|显示文本]]                  # 带别名
- [[note#heading]]                   # 链接到标题

# 外部链接
- [显示文本](https://example.com)

# 图片
![图片描述](image.png)

# 代码块
```python
def hello():
    print("Hello, World!")
```

# 引用
> 这是引用内容
> — 来源说明
```

---

## 五、API数据模型

### 5.1 Pydantic模型

```python
from pydantic import BaseModel, Field, validator
from typing import Optional, List, Dict
from datetime import datetime
from enum import Enum

# ============================================================================
# 基础模型
# ============================================================================

class MessageType(str, Enum):
    """消息类型"""
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"

class EntityType(str, Enum):
    """实体类型"""
    NOTE = "note"
    OBSERVATION = "observation"
    IDEA = "idea"

class RelationType(str, Enum):
    """关系类型"""
    RELATES_TO = "relates_to"
    BUILDS_ON = "builds_on"
    CONTRADICTS = "contradicts"
    EXTENDS = "extends"
    SUPPORTS = "supports"
    QUESTIONS = "questions"

# ============================================================================
# 请求模型
# ============================================================================

class ChatRequest(BaseModel):
    """对话请求"""
    message: str = Field(..., min_length=1, max_length=5000)
    conversation_id: Optional[str] = Field(None, regex=r"^[a-zA-Z0-9-]{1,50}$")
    options: Optional[ChatOptions] = None

    @validator('message')
    def validate_message(cls, v):
        return v.strip()

class ChatOptions(BaseModel):
    """对话选项"""
    use_local_stt: bool = False
    prefer_local_stt: bool = False
    model: str = "auto"  # auto, haiku, sonnet
    stream: bool = False
    save_memory: bool = True

class CreateMemoryRequest(BaseModel):
    """创建记忆请求"""
    title: str = Field(..., min_length=1, max_length=200)
    content: str = Field(..., min_length=1, max_length=50000)
    type: EntityType = EntityType.NOTE
    tags: Optional[List[str]] = Field(None, max_items=10)
    categories: Optional[List[str]] = None
    relations: Optional[List[RelationRequest]] = Field(None, max_items=20)
    metadata: Optional[Dict] = None

    @validator('tags')
    def validate_tags(cls, v):
        if v:
            for tag in v:
                if not re.match(r'^[a-zA-Z0-9-_]{1,30}$', tag):
                    raise ValueError(f"Invalid tag format: {tag}")
        return v

class RelationRequest(BaseModel):
    """关系请求"""
    target_permalink: str
    relation_type: RelationType
    context: Optional[str] = None

# ============================================================================
# 响应模型
# ============================================================================

class ChatResponse(BaseModel):
    """对话响应"""
    response: str
    conversation_id: str
    message_id: str
    usage: UsageInfo
    transcription: Optional[TranscriptionInfo] = None
    memory_saved: Optional[MemorySavedInfo] = None
    timings: TimingsInfo

class UsageInfo(BaseModel):
    """使用信息"""
    input_tokens: int
    output_tokens: int
    total_tokens: int
    model: str
    estimated_cost: float

class TranscriptionInfo(BaseModel):
    """转写信息"""
    text: str
    confidence: float
    language: str
    duration: float

class MemorySavedInfo(BaseModel):
    """记忆保存信息"""
    saved: bool
    permalink: Optional[str] = None
    auto_summarized: bool = False

class TimingsInfo(BaseModel):
    """时间信息"""
    stt_duration_ms: int
    ai_duration_ms: int
    tts_duration_ms: int
    total_duration_ms: int

class MemoryResponse(BaseModel):
    """记忆响应"""
    permalink: str
    title: str
    content: str
    type: EntityType
    tags: List[str]
    categories: List[str]
    created_at: datetime
    updated_at: datetime
    observations: List[ObservationResponse] = []
    relations: List[RelationResponse] = []

class ObservationResponse(BaseModel):
    """观察记录响应"""
    id: int
    category: str
    content: str
    tags: List[str]
    created_at: datetime

class RelationResponse(BaseModel):
    """关系响应"""
    id: int
    target_permalink: str
    target_title: str
    relation_type: RelationType
    context: Optional[str] = None

# ============================================================================
# 通用模型
# ============================================================================

class ErrorResponse(BaseModel):
    """错误响应"""
    success: bool = False
    error: ErrorDetail

class ErrorDetail(BaseModel):
    """错误详情"""
    code: str
    message: str
    details: Optional[List[ValidationError]] = None

class ValidationError(BaseModel):
    """验证错误"""
    field: str
    message: str
    constraint: Optional[str] = None

class PaginationInfo(BaseModel):
    """分页信息"""
    page: int
    limit: int
    total: int
    total_pages: int

class MetaInfo(BaseModel):
    """元信息"""
    request_id: str
    timestamp: datetime
    version: str = "1.0.0"
```

### 5.2 SQLAlchemy模型

```python
from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean, ForeignKey, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()

class Entity(Base):
    """实体模型"""
    __tablename__ = "entities"

    id = Column(Integer, primary_key=True, autoincrement=True)
    title = Column(String(200), nullable=False)
    permalink = Column(String(200), unique=True, nullable=False, index=True)
    type = Column(String(50), default="note", index=True)
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, index=True)
    source = Column(String(50))
    source_id = Column(String(100))
    view_count = Column(Integer, default=0)
    edit_count = Column(Integer, default=0)
    markdown_path = Column(String(500))

    # 关系
    observations = relationship("Observation", back_populates="entity", cascade="all, delete-orphan")
    source_relations = relationship("Relation", foreign_keys="Relation.source_entity_id", back_populates="source_entity")
    target_relations = relationship("Relation", foreign_keys="Relation.target_entity_id", back_populates="target_entity")
    entity_tags = relationship("EntityTag", back_populates="entity", cascade="all, delete-orphan")

class Observation(Base):
    """观察记录模型"""
    __tablename__ = "observations"

    id = Column(Integer, primary_key=True, autoincrement=True)
    entity_id = Column(Integer, ForeignKey("entities.id", ondelete="CASCADE"), nullable=False, index=True)
    category = Column(String(100), index=True)
    content = Column(Text, nullable=False)
    tags = Column(JSON)  # 存储为JSON数组
    context = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow, index=True)

    # 关系
    entity = relationship("Entity", back_populates="observations")

class Relation(Base):
    """关系模型"""
    __tablename__ = "relations"

    id = Column(Integer, primary_key=True, autoincrement=True)
    source_entity_id = Column(Integer, ForeignKey("entities.id", ondelete="CASCADE"), nullable=False, index=True)
    target_entity_id = Column(Integer, ForeignKey("entities.id", ondelete="CASCADE"), nullable=False, index=True)
    relation_type = Column(String(50), nullable=False, index=True)
    context = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 关系
    source_entity = relationship("Entity", foreign_keys=[source_entity_id], back_populates="source_relations")
    target_entity = relationship("Entity", foreign_keys=[target_entity_id], back_populates="target_relations")

class Conversation(Base):
    """会话模型"""
    __tablename__ = "conversations"

    id = Column(Integer, primary_key=True, autoincrement=True)
    conversation_id = Column(String(100), unique=True, nullable=False, index=True)
    title = Column(String(200))
    system_prompt = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, index=True)
    message_count = Column(Integer, default=0)
    total_tokens = Column(Integer, default=0)

    # 关系
    messages = relationship("Message", back_populates="conversation", cascade="all, delete-orphan")

class Message(Base):
    """消息模型"""
    __tablename__ = "messages"

    id = Column(Integer, primary_key=True, autoincrement=True)
    message_id = Column(String(100), unique=True, nullable=False, index=True)
    conversation_id = Column(String(100), ForeignKey("conversations.conversation_id", ondelete="CASCADE"), nullable=False, index=True)
    role = Column(String(20), nullable=False)  # user, assistant, system
    content = Column(Text, nullable=False)
    input_tokens = Column(Integer, default=0)
    output_tokens = Column(Integer, default=0)
    model = Column(String(100))
    created_at = Column(DateTime, default=datetime.utcnow, index=True)

    # 关系
    conversation = relationship("Conversation", back_populates="messages")

class Tag(Base):
    """标签模型"""
    __tablename__ = "tags"

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(100), unique=True, nullable=False, index=True)
    color = Column(String(20), default="#3498db")
    description = Column(Text)
    usage_count = Column(Integer, default=0, index=True)
    created_at = Column(DateTime, default=datetime.utcnow)

class EntityTag(Base):
    """实体标签关联模型"""
    __tablename__ = "entity_tags"

    id = Column(Integer, primary_key=True, autoincrement=True)
    entity_id = Column(Integer, ForeignKey("entities.id", ondelete="CASCADE"), nullable=False, index=True)
    tag_id = Column(Integer, ForeignKey("tags.id", ondelete="CASCADE"), nullable=False, index=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    # 关系
    entity = relationship("Entity", back_populates="entity_tags")
    tag = relationship("Tag")
```

---

## 六、索引策略

### 6.1 索引设计原则

```yaml
查询优化:
  ✅ 为常用查询字段创建索引
  ✅ 为外键创建索引
  ✅ 为排序字段创建索引
  ✅ 为搜索字段创建索引

写入性能:
  ✅ 避免过度索引
  ✅ 复合索引优化
  ✅ 定期维护索引

存储空间:
  ✅ 索引占用空间
  ✅ 索引重建成本
```

### 6.2 关键索引

```sql
-- entities表
CREATE INDEX idx_entities_permalink ON entities(permalink);           -- 唯一查询
CREATE INDEX idx_entities_type ON entities(type);                     -- 类型过滤
CREATE INDEX idx_entities_created_at ON entities(created_at DESC);    -- 时间排序
CREATE INDEX idx_entities_updated_at ON entities(updated_at DESC);    -- 更新排序

-- observations表
CREATE INDEX idx_observations_entity_id ON observations(entity_id);    -- 关联查询
CREATE INDEX idx_observations_category ON observations(category);      -- 分类过滤
CREATE INDEX idx_observations_created_at ON observations(created_at);  -- 时间排序

-- relations表
CREATE INDEX idx_relations_source ON relations(source_entity_id);     -- 源查询
CREATE INDEX idx_relations_target ON relations(target_entity_id);     -- 目标查询
CREATE INDEX idx_relations_type ON relations(relation_type);          -- 类型过滤

-- messages表
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id); -- 会话查询
CREATE INDEX idx_messages_created_at ON messages(created_at);         -- 时间排序

-- 全文搜索索引（Phase 2）
CREATE VIRTUAL TABLE entities_fts USING fts5(
    title,
    content,
    content=entities,
    content_rowid=rowid
);

-- 触发器同步全文搜索
CREATE TRIGGER entities_fts_insert AFTER INSERT ON entities BEGIN
    INSERT INTO entities_fts(rowid, title, content)
    VALUES (new.id, new.title, new.content);
END;

CREATE TRIGGER entities_fts_delete AFTER DELETE ON entities BEGIN
    DELETE FROM entities_fts WHERE rowid = old.id;
END;

CREATE TRIGGER entities_fts_update AFTER UPDATE ON entities BEGIN
    DELETE FROM entities_fts WHERE rowid = old.id;
    INSERT INTO entities_fts(rowid, title, content)
    VALUES (new.id, new.title, new.content);
END;
```

---

## 七、数据迁移

### 7.1 版本迁移策略

```yaml
迁移工具:
  - Alembic（Python）
  - 自动迁移脚本
  - 手动SQL脚本

迁移原则:
  ✅ 向后兼容
  ✅ 可回滚
  ✅ 数据备份
  ✅ 测试验证
```

### 7.2 Alembic配置

```python
# alembic/env.py

from alembic import context
from sqlalchemy import engine_from_config, pool
from logging.config import fileConfig

# 导入Base
from backend.models.database import Base

# 导入所有模型
from backend.models import (
    Entity,
    Observation,
    Relation,
    Conversation,
    Message,
    User,
    Tag,
    EntityTag
)

# Alembic Config对象
config = context.config

# 解释日志配置
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# 设置元数据
target_metadata = Base.metadata

def run_migrations_online() -> None:
    """在线迁移模式"""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            compare_type=True,
        )

        with context.begin_transaction():
            context.run_migrations()

def run_migrations_offline() -> None:
    """离线迁移模式"""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
```

### 7.3 迁移脚本示例

```python
# alembic/versions/001_initial_schema.py

"""Initial schema

Revision ID: 001
Revises:
Create Date: 2025-12-29
"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    # 创建entities表
    op.create_table(
        'entities',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('title', sa.String(length=200), nullable=False),
        sa.Column('permalink', sa.String(length=200), nullable=False),
        sa.Column('type', sa.String(length=50), server_default='note', nullable=True),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
        sa.Column('updated_at', sa.DateTime(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('permalink')
    )
    op.create_index('idx_entities_permalink', 'entities', ['permalink'])
    op.create_index('idx_entities_type', 'entities', ['type'])
    op.create_index('idx_entities_created_at', 'entities', ['created_at'])

    # 创建observations表
    op.create_table(
        'observations',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('entity_id', sa.Integer(), nullable=False),
        sa.Column('category', sa.String(length=100), nullable=True),
        sa.Column('content', sa.Text(), nullable=False),
        sa.Column('tags', sa.JSON(), nullable=True),
        sa.Column('context', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
        sa.ForeignKeyConstraint(['entity_id'], ['entities.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index('idx_observations_entity_id', 'observations', ['entity_id'])
    op.create_index('idx_observations_category', 'observations', ['category'])

    # 创建relations表
    op.create_table(
        'relations',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('source_entity_id', sa.Integer(), nullable=False),
        sa.Column('target_entity_id', sa.Integer(), nullable=False),
        sa.Column('relation_type', sa.String(length=50), nullable=False),
        sa.Column('context', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
        sa.ForeignKeyConstraint(['source_entity_id'], ['entities.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['target_entity_id'], ['entities.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('source_entity_id', 'target_entity_id', 'relation_type')
    )
    op.create_index('idx_relations_source', 'relations', ['source_entity_id'])
    op.create_index('idx_relations_target', 'relations', ['target_entity_id'])
    op.create_index('idx_relations_type', 'relations', ['relation_type'])

def downgrade():
    op.drop_index('idx_relations_type', table_name='relations')
    op.drop_index('idx_relations_target', table_name='relations')
    op.drop_index('idx_relations_source', table_name='relations')
    op.drop_table('relations')

    op.drop_index('idx_observations_category', table_name='observations')
    op.drop_index('idx_observations_entity_id', table_name='observations')
    op.drop_table('observations')

    op.drop_index('idx_entities_created_at', table_name='entities')
    op.drop_index('idx_entities_type', table_name='entities')
    op.drop_index('idx_entities_permalink', table_name='entities')
    op.drop_table('entities')
```

---

**文档版本历史：**
- v1.0 (2025-12-29): 初始版本，完整数据模型设计
